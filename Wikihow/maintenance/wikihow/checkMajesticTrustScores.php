<?php

require_once __DIR__ . '/../Maintenance.php';

/*
 * Grab the trust score for article domains found in different csv input files
 *
 * TYPE_REFERENCES: references csv generated by the udpateArticleReferences.php script and
 * output that to a new csv with columns for trust score and potential error information
 *
 * TYPE_BACKLINKS: backlinks file generated by label_disavow.py - a script created by ramanjot and chris to analyze
 * ahrefs data files and generate potential domains to disavow
 */
class CheckMajesticTrustScores extends Maintenance {
	var $limit = 0;
	var $type = '';
	const TYPE_REFERENCES = 'references';
	const TYPE_BACKLINKS = 'backlinks';
	var $inputFilename ='';
	var $outputFilename = "majesticScores.tsv";
	const API_ENDPOINT = 'https://api.majestic.com/api/json?app_api_key=4F0D6D129CDA6879EF26B767756796EE&cmd=GetRefDomainInfo&items=1&datasource=fresh&item0=';
	var $last_error = '';
	var $trustScore = -1;

    public function __construct() {
        parent::__construct();
        $this->mDescription = "check article references trust score";
		$this->addOption( 'limit', 'number of items to process', false, true, 'l' );
	    $this->addOption( 'type', "the type of input file to process. valid values are 'references' or 'backlinks'", true, false, 'i' );
		$this->addOption( 'ifname', 'the name of the csv file to process', true, false, 'i' );
	    $this->addOption( 'ofname', 'the name of the tsv file to output. Defaults to majesticScores.tsv', false, false, 'o' );
    }

	public function execute() {
		$this->handleOptions();

		$i = 1;
		if (($handleIn = fopen($this->inputFilename, "r")) !== FALSE &&
			($handleOut = fopen($this->outputFilename, "w")) !== FALSE) {
			while (($data = fgetcsv($handleIn, 0)) !== FALSE) {
				// Skip backlinks file header row
				if ($this->type == self::TYPE_BACKLINKS && $i++ == 1) {
					array_push($data, "majestic score", "notes");
					fputcsv($handleOut, $data, "\t");
					continue;
				}

				$this->last_error = "";
				$this->trustScore = -1;
				// Get trust score for top-level domain
				// hack for bad data in input file for *.co.uk domains
				$score = $this->getTrustScore($this->getTopLevelDomain($data));
				array_push($data, $score, $this->last_error);
				var_dump($data);
				fputcsv($handleOut, $data, "\t");
				if ($this->limit > 0 && $i == $this->limit) {
					break;
				}
				$i++;
			}
			fclose($handleIn);
			fclose($handleOut);
		}
	}

	function getTopLevelDomain($data) {
    	$type = $this->type;
    	$domain = '';
		if ($type == self::TYPE_REFERENCES) {
			$domain = strtolower($data[5]) == "co.uk"
				? strtolower($data[4]) : strtolower($data[5]);
		} else {
			// self::TYPE_BACKLINKS
			$domain = strtolower($data[0]);

		}

		return $domain;
	}

	function getTrustScore($tld) {
		$cachedScore = $this->getScoreCache($tld);
		if ($cachedScore) {
			var_dump('cache hit');
			return $cachedScore;
		}
		
		$score = -1;
    	$data = $this->getMajesticData($tld);
    	if ($data) {
    		$data = json_decode($data, true);
    		if ($data['Code'] == "OK")  {
			    if(isset($data['DataTables']['DomainsInfo']['Data'][0]['TrustFlow'])) {
				    $score = $data['DataTables']['DomainsInfo']['Data'][0]['TrustFlow'];
				    $status = $data['DataTables']['DomainsInfo']['Data'][0]['Status'];
				    if ($status != "Found") {
					    $this->last_error = "msg: Domain not found, no TrustFlow data";
				    }
				    $this->setScoreCache($tld, $score);
			    } else {
			    	$this->last_error = "msg: TrustFlow not set in response";
			    }
		    } else {
    			$this->last_error = $this->getErrorMsg($data);
		    }
	    } else {
		    $this->last_error = "msg: unable to retrieve data";
	    }

	    $this->trustScore = $score;
	    return $score;
	}

	function setScoreCache($tld, $score) {
		global $wgMemc;
		$cacheKey = $this->getCacheKey($tld);
		$wgMemc->set($cacheKey, $score);
	}

	function getScoreCache($tld) {
		global $wgMemc;
		$cacheKey = $this->getCacheKey($tld);
    	return $wgMemc->get($cacheKey);
	}

	function getCacheKey($tld) {
		return wfMemcKey('majestic_score', $tld);
	}

	function getErrorMsg($data) {
    	return "msg: " . $data['ErrorMessage'] . ". Full err: " . $data['FullError'];
	}

	function getMajesticData($tld) {
    	return file_get_contents(self::API_ENDPOINT . $tld);
	}

	protected function handleOptions() {
		if ($this->hasOption('type')) {
			$this->type = $this->getOption('type');
		}


		var_dump($this->type);
		if ($this->type != self::TYPE_REFERENCES && $this->type != self::TYPE_BACKLINKS) {
			echo "type must be specified as either backlinks or references. See comments in the head of this script "
				. "for information on where to obtain source input file types.\n";
			exit;
		}

		if ($this->hasOption('limit')) {
			$this->limit = $this->getOption('limit');
		}


		if ($this->hasOption('ifname')) {
			$this->inputFilename = $this->getOption('ifname');
		}

		if ($this->hasOption('ofname')) {
			$this->outputFilename = $this->getOption('ofname');
		}
	}
}


$maintClass = "CheckMajesticTrustScores";
require_once RUN_MAINTENANCE_IF_MAIN;

