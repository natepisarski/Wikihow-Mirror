{"version":3,"sources":["webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/WatchList.js","webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/WatchListGateway.js","webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/mobile.special.watchlist.scripts.js"],"names":["mfExtend","require","PageList","WatchstarPageList","ScrollEndEventEmitter","util","WatchListGateway","WatchList","params","lastTitle","options","extend","isBorderBox","this","scrollEndEventEmitter","eventBus","on","EVENT_SCROLL_END","_loadPages","bind","el","getLastTitle","gateway","api","call","preRender","disable","setElement","$el","postRender","$items","statuses","prototype","apply","queryUnitializedItems","Object","keys","parsePagesFromItems","reduce","title","renderItems","enable","loadWatchlist","then","pages","forEach","page","appendPage","render","templateOptions","wikidataDescription","undefined","append","templatePartials","item","find","attr","module","exports","Page","extendSearchParams","limit","continueParams","continue","gwrcontinue","replace","shouldSkipFirstTitle","canContinue","self","prop","rvprop","generator","gwrnamespace","gwrlimit","Deferred","resolve","get","url","apiUrl","data","parseData","query","sort","p1","p2","slice","map","newFromJSON","userOptions","mw","user","$","Api","view","filter","$watchlist","length","funnel","skipTemplateRender","remove","init","saveOption"],"mappings":"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","file":"mobile.special.watchlist.scripts.js","sourcesContent":["var\n\tmfExtend = require( '../mobile.startup/mfExtend' ),\n\tPageList = require( '../mobile.startup/PageList' ),\n\tWatchstarPageList = require( '../mobile.startup/watchstar/WatchstarPageList' ),\n\tScrollEndEventEmitter = require( '../mobile.startup/ScrollEndEventEmitter' ),\n\tutil = require( '../mobile.startup/util' ),\n\tWatchListGateway = require( './WatchListGateway' );\n\n/**\n * An extension of the WatchstarPageList which preloads pages as all being\n * watched.\n * @extends WatchstarPageList\n * @class WatchList\n * @uses ScrollEndEventEmitter\n *\n * @fires watched\n * @fires watch\n * @param {Object} params Configuration options\n * @param {OO.EventEmitter} params.eventBus Object used to listen for scroll:throttled events\n */\nfunction WatchList( params ) {\n\tvar lastTitle,\n\t\toptions = util.extend( {}, {\n\t\t\tisBorderBox: false\n\t\t}, params );\n\n\t// Set up infinite scroll helper and listen to events\n\tthis.scrollEndEventEmitter = new ScrollEndEventEmitter( options.eventBus );\n\tthis.scrollEndEventEmitter.on( ScrollEndEventEmitter.EVENT_SCROLL_END,\n\t\tthis._loadPages.bind( this ) );\n\n\tif ( options.el ) {\n\t\tlastTitle = this.getLastTitle( options.el );\n\t}\n\tthis.gateway = new WatchListGateway( options.api, lastTitle );\n\n\tWatchstarPageList.call( this, options );\n}\n\nmfExtend( WatchList, WatchstarPageList, {\n\t/**\n\t * @inheritdoc\n\t * @memberof WatchList\n\t * @instance\n\t */\n\tpreRender: function () {\n\t\t// The DOM will be modified. Prevent any false scroll end events from\n\t\t// being emitted.\n\t\tthis.scrollEndEventEmitter.disable();\n\t\tthis.scrollEndEventEmitter.setElement( this.$el );\n\t},\n\t/**\n\t * Also sets a watch uploads funnel.\n\t * @inheritdoc\n\t * @memberof WatchList\n\t * @instance\n\t */\n\tpostRender: function () {\n\t\tvar\n\t\t\t$items,\n\t\t\tstatuses;\n\n\t\t// Skip a level from WatchstarPageList directly to PageList.\n\t\tPageList.prototype.postRender.apply( this );\n\n\t\t$items = this.queryUnitializedItems();\n\n\t\t// WatchList requests list of watched pages. The list contains only\n\t\t// watched pages so it's safe to transform the title map to a status map\n\t\t// with each entry marked watched (true).\n\t\tstatuses = Object.keys( this.parsePagesFromItems( $items ) )\n\t\t\t.reduce( function ( statuses, title ) {\n\t\t\t\tstatuses[ title ] = true;\n\t\t\t\treturn statuses;\n\t\t\t}, {} );\n\t\tthis.renderItems( $items, statuses );\n\n\t\t// The list has been extended. Re-enable scroll end events.\n\t\tthis.scrollEndEventEmitter.enable();\n\t},\n\n\t/**\n\t * Loads pages from the api and triggers render.\n\t * Infinite scroll is re-enabled in postRender.\n\t * @memberof WatchList\n\t * @instance\n\t */\n\t_loadPages: function () {\n\t\tthis.gateway.loadWatchlist().then( function ( pages ) {\n\t\t\tpages.forEach( function ( page ) {\n\t\t\t\tthis.appendPage( page );\n\t\t\t}.bind( this ) );\n\t\t\tthis.render();\n\t\t}.bind( this ) );\n\t},\n\n\t/**\n\t * Appends a list item\n\t * @memberof WatchList\n\t * @instance\n\t * @param {Page} page\n\t */\n\tappendPage: function ( page ) {\n\t\t// wikidata descriptions should not show in this view.\n\t\tvar templateOptions = util.extend( {}, page.options, {\n\t\t\twikidataDescription: undefined\n\t\t} );\n\t\tthis.$el.append( this.templatePartials.item.render( templateOptions ) );\n\t},\n\n\t/**\n\t * Get the last title from the rendered HTML.\n\t * Used for initializing the API\n\t * @memberof WatchList\n\t * @instance\n\t * @param {jQuery.Object} $el Dom element of the list\n\t * @return {string}\n\t */\n\tgetLastTitle: function ( $el ) {\n\t\treturn $el.find( 'li:last' ).attr( 'title' );\n\t}\n} );\n\nmodule.exports = WatchList;\n","var Page = require( '../mobile.startup/Page' ),\n\tutil = require( '../mobile.startup/util' ),\n\textendSearchParams = require( '../mobile.startup/extendSearchParams' );\n\n/**\n * @class WatchListGateway\n * @param {mw.Api} api\n * @param {string} lastTitle of page listed in Watchlist to be used as a continuation parameter\n */\nfunction WatchListGateway( api, lastTitle ) {\n\tthis.api = api;\n\t// Try to keep it in sync with SpecialMobileWatchlist::LIMIT (php)\n\tthis.limit = 50;\n\n\tif ( lastTitle ) {\n\t\tthis.continueParams = {\n\t\t\tcontinue: 'gwrcontinue||',\n\t\t\tgwrcontinue: '0|' + lastTitle.replace( / /g, '_' )\n\t\t};\n\t\tthis.shouldSkipFirstTitle = true;\n\t} else {\n\t\tthis.continueParams = {\n\t\t\tcontinue: ''\n\t\t};\n\t\tthis.shouldSkipFirstTitle = false;\n\t}\n\n\tthis.canContinue = true;\n}\n\nWatchListGateway.prototype = {\n\t/**\n\t * Load the list of items on the watchlist\n\t * @return {jQuery.Deferred}\n\t */\n\tloadWatchlist: function () {\n\t\tvar self = this,\n\t\t\tparams = extendSearchParams( 'watchlist', {\n\t\t\t\tprop: [ 'info', 'revisions' ],\n\t\t\t\trvprop: 'timestamp|user',\n\t\t\t\tgenerator: 'watchlistraw',\n\t\t\t\tgwrnamespace: '0',\n\t\t\t\tgwrlimit: this.limit\n\t\t\t}, this.continueParams );\n\n\t\tif ( this.canContinue === false ) {\n\t\t\treturn util.Deferred().resolve( [] );\n\t\t}\n\t\treturn this.api.get( params, {\n\t\t\turl: this.apiUrl\n\t\t} ).then( function ( data ) {\n\t\t\tif ( data.continue !== undefined ) {\n\t\t\t\tself.continueParams = data.continue;\n\t\t\t} else {\n\t\t\t\tself.canContinue = false;\n\t\t\t}\n\n\t\t\treturn self.parseData( data );\n\t\t} );\n\t},\n\n\t/**\n\t * Parse api response data into pagelist item format\n\t * @param {Object[]} data\n\t * @return {Page[]}\n\t */\n\tparseData: function ( data ) {\n\t\tvar pages;\n\n\t\tif ( !data.query || !data.query.pages ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tpages = data.query.pages;\n\n\t\t// Sort results alphabetically (the api map doesn't have any order). The\n\t\t// watchlist is ordered alphabetically right now.\n\t\tpages.sort( function ( p1, p2 ) {\n\t\t\treturn p1.title === p2.title ? 0 : ( p1.title < p2.title ? -1 : 1 );\n\t\t} );\n\n\t\t// If we requested from the last item of the previous page, we shall\n\t\t// remove the first result (to avoid it being repeated)\n\t\tif ( this.shouldSkipFirstTitle ) {\n\t\t\tpages = pages.slice( 1 );\n\t\t\tthis.shouldSkipFirstTitle = false;\n\t\t}\n\n\t\t// Transform the items to a sensible format\n\t\treturn pages.map( Page.newFromJSON );\n\t}\n\n};\n\nmodule.exports = WatchListGateway;\n","/* global $ */\nvar WatchList = require( './WatchList' ),\n\teventBus = require( '../mobile.startup/eventBusSingleton' ),\n\tVIEW_OPTION_NAME = 'mfWatchlistView',\n\tuserOptions = mw.user.options.get(),\n\tFILTER_OPTION_NAME = 'mfWatchlistFilter';\n\n/**\n * Initialises JavaScript on Special:Watchlist\n */\nfunction init() {\n\tvar $watchlist = $( 'ul.page-list' );\n\n\t// FIXME: find more elegant way to not show watchlist stars on recent changes\n\tif ( $( '.mw-mf-watchlist-selector' ).length === 0 ) {\n\t\t// eslint-disable-next-line no-new\n\t\tnew WatchList( {\n\t\t\tapi: new mw.Api(),\n\t\t\tel: $watchlist,\n\t\t\tfunnel: 'watchlist',\n\t\t\tskipTemplateRender: true,\n\t\t\teventBus: eventBus\n\t\t} );\n\t}\n\t// not needed now we have JS view which has infinite scrolling\n\t$( '.more' ).remove();\n}\n\n$( function () {\n\tvar api = new mw.Api(),\n\t\tview = $( '.button-bar .is-on a' ).data( 'view' ),\n\t\tfilter = $( '.mw-mf-watchlist-selector .selected a' ).data( 'filter' );\n\n\tinit();\n\t// Only save if the value has changed.\n\tif ( view !== userOptions[VIEW_OPTION_NAME] ) {\n\t\tapi.saveOption( VIEW_OPTION_NAME, view );\n\t}\n\tif ( filter && filter !== userOptions[FILTER_OPTION_NAME] ) {\n\t\tapi.saveOption( FILTER_OPTION_NAME, filter );\n\t}\n} );\n"],"sourceRoot":""}