{"version":3,"sources":["webpack://mfModules.[name]/./node_modules/hogan.js/lib/compiler.js","webpack://mfModules.[name]/./node_modules/hogan.js/lib/hogan.js","webpack://mfModules.[name]/./node_modules/hogan.js/lib/template.js","webpack://mfModules.[name]/./src/mediawiki.template.hogan/mediawiki.template.hogan.js"],"names":["Hogan","rIsWhitespace","rQuot","rNewline","rCr","rSlash","tagTypes","#","^","/","!",">","<","=","_v","{","&","cleanTripleStache","token","n","substr","length","substring","trim","s","replace","tagChange","tag","text","index","charAt","i","l","isOpener","tags","o","isCloser","close","open","c","esc","chooseMethod","indexOf","walk","tree","code","section","nodes","end","otag","ctag","invertedSection","partial","tripleStache","variable","undefined","id","method","start","tok","indent","scan","delimiters","len","state","tagType","buf","tokens","seenTag","lineStart","addBuf","push","String","filterLine","haveSeenTag","noNewLine","isAllWhitespace","j","match","lineIsWhitespace","next","toString","splice","changeDelimiters","closeIndex","split","generate","options","asString","Template","Function","parse","buildTree","kind","stack","customTags","instructions","opener","shift","Error","pop","sectionTags","cache","compile","key","t","this","exports","__webpack_require__","module","useArrayBuffer","renderFunc","compiler","r","prototype","context","partials","v","str","coerceToString","hChars","test","rAmp","rLt","rGt","rApos","render","ri","rp","name","rs","tail","isArray","val","ctx","inverted","pass","ls","d","returnFound","names","f","cx","lv","found","ho","call","b","fl","result","Array","a","Object","require","mw","template","registerCompiler","bind"],"mappings":"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","file":"mediawiki.template.hogan.js","sourcesContent":["/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n(function (Hogan) {\n  // Setup regex  assignments\n  // remove whitespace according to Mustache spec\n  var rIsWhitespace = /\\S/,\n      rQuot = /\\\"/g,\n      rNewline =  /\\n/g,\n      rCr = /\\r/g,\n      rSlash = /\\\\/g,\n      tagTypes = {\n        '#': 1, '^': 2, '/': 3,  '!': 4, '>': 5,\n        '<': 6, '=': 7, '_v': 8, '{': 9, '&': 10\n      };\n\n  Hogan.scan = function scan(text, delimiters) {\n    var len = text.length,\n        IN_TEXT = 0,\n        IN_TAG_TYPE = 1,\n        IN_TAG = 2,\n        state = IN_TEXT,\n        tagType = null,\n        tag = null,\n        buf = '',\n        tokens = [],\n        seenTag = false,\n        i = 0,\n        lineStart = 0,\n        otag = '{{',\n        ctag = '}}';\n\n    function addBuf() {\n      if (buf.length > 0) {\n        tokens.push(new String(buf));\n        buf = '';\n      }\n    }\n\n    function lineIsWhitespace() {\n      var isAllWhitespace = true;\n      for (var j = lineStart; j < tokens.length; j++) {\n        isAllWhitespace =\n          (tokens[j].tag && tagTypes[tokens[j].tag] < tagTypes['_v']) ||\n          (!tokens[j].tag && tokens[j].match(rIsWhitespace) === null);\n        if (!isAllWhitespace) {\n          return false;\n        }\n      }\n\n      return isAllWhitespace;\n    }\n\n    function filterLine(haveSeenTag, noNewLine) {\n      addBuf();\n\n      if (haveSeenTag && lineIsWhitespace()) {\n        for (var j = lineStart, next; j < tokens.length; j++) {\n          if (!tokens[j].tag) {\n            if ((next = tokens[j+1]) && next.tag == '>') {\n              // set indent to token value\n              next.indent = tokens[j].toString()\n            }\n            tokens.splice(j, 1);\n          }\n        }\n      } else if (!noNewLine) {\n        tokens.push({tag:'\\n'});\n      }\n\n      seenTag = false;\n      lineStart = tokens.length;\n    }\n\n    function changeDelimiters(text, index) {\n      var close = '=' + ctag,\n          closeIndex = text.indexOf(close, index),\n          delimiters = trim(\n            text.substring(text.indexOf('=', index) + 1, closeIndex)\n          ).split(' ');\n\n      otag = delimiters[0];\n      ctag = delimiters[1];\n\n      return closeIndex + close.length - 1;\n    }\n\n    if (delimiters) {\n      delimiters = delimiters.split(' ');\n      otag = delimiters[0];\n      ctag = delimiters[1];\n    }\n\n    for (i = 0; i < len; i++) {\n      if (state == IN_TEXT) {\n        if (tagChange(otag, text, i)) {\n          --i;\n          addBuf();\n          state = IN_TAG_TYPE;\n        } else {\n          if (text.charAt(i) == '\\n') {\n            filterLine(seenTag);\n          } else {\n            buf += text.charAt(i);\n          }\n        }\n      } else if (state == IN_TAG_TYPE) {\n        i += otag.length - 1;\n        tag = tagTypes[text.charAt(i + 1)];\n        tagType = tag ? text.charAt(i + 1) : '_v';\n        if (tagType == '=') {\n          i = changeDelimiters(text, i);\n          state = IN_TEXT;\n        } else {\n          if (tag) {\n            i++;\n          }\n          state = IN_TAG;\n        }\n        seenTag = i;\n      } else {\n        if (tagChange(ctag, text, i)) {\n          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\n                       i: (tagType == '/') ? seenTag - ctag.length : i + otag.length});\n          buf = '';\n          i += ctag.length - 1;\n          state = IN_TEXT;\n          if (tagType == '{') {\n            if (ctag == '}}') {\n              i++;\n            } else {\n              cleanTripleStache(tokens[tokens.length - 1]);\n            }\n          }\n        } else {\n          buf += text.charAt(i);\n        }\n      }\n    }\n\n    filterLine(seenTag, true);\n\n    return tokens;\n  }\n\n  function cleanTripleStache(token) {\n    if (token.n.substr(token.n.length - 1) === '}') {\n      token.n = token.n.substring(0, token.n.length - 1);\n    }\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s*|\\s*$/g, '');\n  }\n\n  function tagChange(tag, text, index) {\n    if (text.charAt(index) != tag.charAt(0)) {\n      return false;\n    }\n\n    for (var i = 1, l = tag.length; i < l; i++) {\n      if (text.charAt(index + i) != tag.charAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function buildTree(tokens, kind, stack, customTags) {\n    var instructions = [],\n        opener = null,\n        token = null;\n\n    while (tokens.length > 0) {\n      token = tokens.shift();\n      if (token.tag == '#' || token.tag == '^' || isOpener(token, customTags)) {\n        stack.push(token);\n        token.nodes = buildTree(tokens, token.tag, stack, customTags);\n        instructions.push(token);\n      } else if (token.tag == '/') {\n        if (stack.length === 0) {\n          throw new Error('Closing tag without opener: /' + token.n);\n        }\n        opener = stack.pop();\n        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\n          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\n        }\n        opener.end = token.i;\n        return instructions;\n      } else {\n        instructions.push(token);\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new Error('missing closing tag: ' + stack.pop().n);\n    }\n\n    return instructions;\n  }\n\n  function isOpener(token, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].o == token.n) {\n        token.tag = '#';\n        return true;\n      }\n    }\n  }\n\n  function isCloser(close, open, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].c == close && tags[i].o == open) {\n        return true;\n      }\n    }\n  }\n\n  Hogan.generate = function (tree, text, options) {\n    var code = 'var _=this;_.b(i=i||\"\");' + walk(tree) + 'return _.fl();';\n    if (options.asString) {\n      return 'function(c,p,i){' + code + ';}';\n    }\n\n    return new Hogan.Template(new Function('c', 'p', 'i', code), text, Hogan, options);\n  }\n\n  function esc(s) {\n    return s.replace(rSlash, '\\\\\\\\')\n            .replace(rQuot, '\\\\\\\"')\n            .replace(rNewline, '\\\\n')\n            .replace(rCr, '\\\\r');\n  }\n\n  function chooseMethod(s) {\n    return (~s.indexOf('.')) ? 'd' : 'f';\n  }\n\n  function walk(tree) {\n    var code = '';\n    for (var i = 0, l = tree.length; i < l; i++) {\n      var tag = tree[i].tag;\n      if (tag == '#') {\n        code += section(tree[i].nodes, tree[i].n, chooseMethod(tree[i].n),\n                        tree[i].i, tree[i].end, tree[i].otag + \" \" + tree[i].ctag);\n      } else if (tag == '^') {\n        code += invertedSection(tree[i].nodes, tree[i].n,\n                                chooseMethod(tree[i].n));\n      } else if (tag == '<' || tag == '>') {\n        code += partial(tree[i]);\n      } else if (tag == '{' || tag == '&') {\n        code += tripleStache(tree[i].n, chooseMethod(tree[i].n));\n      } else if (tag == '\\n') {\n        code += text('\"\\\\n\"' + (tree.length-1 == i ? '' : ' + i'));\n      } else if (tag == '_v') {\n        code += variable(tree[i].n, chooseMethod(tree[i].n));\n      } else if (tag === undefined) {\n        code += text('\"' + esc(tree[i]) + '\"');\n      }\n    }\n    return code;\n  }\n\n  function section(nodes, id, method, start, end, tags) {\n    return 'if(_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),' +\n           'c,p,0,' + start + ',' + end + ',\"' + tags + '\")){' +\n           '_.rs(c,p,' +\n           'function(c,p,_){' +\n           walk(nodes) +\n           '});c.pop();}';\n  }\n\n  function invertedSection(nodes, id, method) {\n    return 'if(!_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),c,p,1,0,0,\"\")){' +\n           walk(nodes) +\n           '};';\n  }\n\n  function partial(tok) {\n    return '_.b(_.rp(\"' +  esc(tok.n) + '\",c,p,\"' + (tok.indent || '') + '\"));';\n  }\n\n  function tripleStache(id, method) {\n    return '_.b(_.t(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\n  }\n\n  function variable(id, method) {\n    return '_.b(_.v(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\n  }\n\n  function text(id) {\n    return '_.b(' + id + ');';\n  }\n\n  Hogan.parse = function(tokens, text, options) {\n    options = options || {};\n    return buildTree(tokens, '', [], options.sectionTags || []);\n  },\n\n  Hogan.cache = {};\n\n  Hogan.compile = function(text, options) {\n    // options\n    //\n    // asString: false (default)\n    //\n    // sectionTags: [{o: '_foo', c: 'foo'}]\n    // An array of object with o and c fields that indicate names for custom\n    // section tags. The example above allows parsing of {{_foo}}{{/foo}}.\n    //\n    // delimiters: A string that overrides the default delimiters.\n    // Example: \"<% %>\"\n    //\n    options = options || {};\n\n    var key = text + '||' + !!options.asString;\n\n    var t = this.cache[key];\n\n    if (t) {\n      return t;\n    }\n\n    t = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);\n    return this.cache[key] = t;\n  };\n})(typeof exports !== 'undefined' ? exports : Hogan);\n","/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n// This file is for use with Node.js. See dist/ for browser files.\n\nvar Hogan = require('./compiler');\nHogan.Template = require('./template').Template;\nmodule.exports = Hogan; ","/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nvar Hogan = {};\n\n(function (Hogan, useArrayBuffer) {\n  Hogan.Template = function (renderFunc, text, compiler, options) {\n    this.r = renderFunc || this.r;\n    this.c = compiler;\n    this.options = options;\n    this.text = text || '';\n    this.buf = (useArrayBuffer) ? [] : '';\n  }\n\n  Hogan.Template.prototype = {\n    // render: replaced by generated code.\n    r: function (context, partials, indent) { return ''; },\n\n    // variable escaping\n    v: hoganEscape,\n\n    // triple stache\n    t: coerceToString,\n\n    render: function render(context, partials, indent) {\n      return this.ri([context], partials || {}, indent);\n    },\n\n    // render internal -- a hook for overrides that catches partials too\n    ri: function (context, partials, indent) {\n      return this.r(context, partials, indent);\n    },\n\n    // tries to find a partial in the curent scope and render it\n    rp: function(name, context, partials, indent) {\n      var partial = partials[name];\n\n      if (!partial) {\n        return '';\n      }\n\n      if (this.c && typeof partial == 'string') {\n        partial = this.c.compile(partial, this.options);\n      }\n\n      return partial.ri(context, partials, indent);\n    },\n\n    // render a section\n    rs: function(context, partials, section) {\n      var tail = context[context.length - 1];\n\n      if (!isArray(tail)) {\n        section(context, partials, this);\n        return;\n      }\n\n      for (var i = 0; i < tail.length; i++) {\n        context.push(tail[i]);\n        section(context, partials, this);\n        context.pop();\n      }\n    },\n\n    // maybe start a section\n    s: function(val, ctx, partials, inverted, start, end, tags) {\n      var pass;\n\n      if (isArray(val) && val.length === 0) {\n        return false;\n      }\n\n      if (typeof val == 'function') {\n        val = this.ls(val, ctx, partials, inverted, start, end, tags);\n      }\n\n      pass = (val === '') || !!val;\n\n      if (!inverted && pass && ctx) {\n        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);\n      }\n\n      return pass;\n    },\n\n    // find values with dotted names\n    d: function(key, ctx, partials, returnFound) {\n      var names = key.split('.'),\n          val = this.f(names[0], ctx, partials, returnFound),\n          cx = null;\n\n      if (key === '.' && isArray(ctx[ctx.length - 2])) {\n        return ctx[ctx.length - 1];\n      }\n\n      for (var i = 1; i < names.length; i++) {\n        if (val && typeof val == 'object' && names[i] in val) {\n          cx = val;\n          val = val[names[i]];\n        } else {\n          val = '';\n        }\n      }\n\n      if (returnFound && !val) {\n        return false;\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        ctx.push(cx);\n        val = this.lv(val, ctx, partials);\n        ctx.pop();\n      }\n\n      return val;\n    },\n\n    // find values with normal names\n    f: function(key, ctx, partials, returnFound) {\n      var val = false,\n          v = null,\n          found = false;\n\n      for (var i = ctx.length - 1; i >= 0; i--) {\n        v = ctx[i];\n        if (v && typeof v == 'object' && key in v) {\n          val = v[key];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return (returnFound) ? false : \"\";\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        val = this.lv(val, ctx, partials);\n      }\n\n      return val;\n    },\n\n    // higher order templates\n    ho: function(val, cx, partials, text, tags) {\n      var compiler = this.c;\n      var options = this.options;\n      options.delimiters = tags;\n      var text = val.call(cx, text);\n      text = (text == null) ? String(text) : text.toString();\n      this.b(compiler.compile(text, options).render(cx, partials));\n      return false;\n    },\n\n    // template result buffering\n    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :\n                          function(s) { this.buf += s; },\n    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :\n                           function() { var r = this.buf; this.buf = ''; return r; },\n\n    // lambda replace section\n    ls: function(val, ctx, partials, inverted, start, end, tags) {\n      var cx = ctx[ctx.length - 1],\n          t = null;\n\n      if (!inverted && this.c && val.length > 0) {\n        return this.ho(val, cx, partials, this.text.substring(start, end), tags);\n      }\n\n      t = val.call(cx);\n\n      if (typeof t == 'function') {\n        if (inverted) {\n          return true;\n        } else if (this.c) {\n          return this.ho(t, cx, partials, this.text.substring(start, end), tags);\n        }\n      }\n\n      return t;\n    },\n\n    // lambda replace variable\n    lv: function(val, ctx, partials) {\n      var cx = ctx[ctx.length - 1];\n      var result = val.call(cx);\n\n      if (typeof result == 'function') {\n        result = coerceToString(result.call(cx));\n        if (this.c && ~result.indexOf(\"{\\u007B\")) {\n          return this.c.compile(result, this.options).render(cx, partials);\n        }\n      }\n\n      return coerceToString(result);\n    }\n\n  };\n\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos =/\\'/g,\n      rQuot = /\\\"/g,\n      hChars =/[&<>\\\"\\']/;\n\n\n  function coerceToString(val) {\n    return String((val === null || val === undefined) ? '' : val);\n  }\n\n  function hoganEscape(str) {\n    str = coerceToString(str);\n    return hChars.test(str) ?\n      str\n        .replace(rAmp,'&amp;')\n        .replace(rLt,'&lt;')\n        .replace(rGt,'&gt;')\n        .replace(rApos,'&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n\n  var isArray = Array.isArray || function(a) {\n    return Object.prototype.toString.call(a) === '[object Array]';\n  };\n\n})(typeof exports !== 'undefined' ? exports : Hogan);\n\n","var Hogan = require( 'hogan.js' );\n\n// register hogan compiler with core\nmw.template.registerCompiler( 'hogan', {\n\tcompile: Hogan.compile.bind( Hogan )\n} );\n"],"sourceRoot":""}